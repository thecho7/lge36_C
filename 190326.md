특정 커맨드(예를 들어 fifo)를 foreground가 아닌 background로 돌리고 싶다!
(foreground는 한 번 입력 받고 끝나는데 반해 back은 계속 돌아가고 있음 (언제까지?))

그러면

  ```Shell
  mkfifo myfifo
  cat hello.txt > myfifo & (뒤에 &가 붙으면 background로 보내겠다)
  ```
  
 그러면 이게 백그라운드 프로세스로 돌아가고 있을 것. 확인할 때는 ps 시리즈로 확인
 
  ```Shell
  # https://arer.tistory.com/150
  ps -l
  ```
===============================================================================

ps를 치면

  ```Shell
  PID  TTY
  000 pts/0
  # 000번 프로세스, 가상 터미널 0번에서 구동 중
  ```
  
===============================================================================  
kill
  ```Shell
  # kill -l 로 SIGNAL 목록을 확인할 수 있음
  # SIGINT = Ctrl + C, SIGKILL(KILL) -> 막을 수가 없는 명령, 무조건 죽임(나머지 대부분의 SIGNAL은 사용자 재정의 가능)
  # 터미널에서 kill -SIGINT (터미널ID) 해도 아무 일 없지만 kill -KILL (터미널ID) 하면 터미널 죽음
  kill -(SIGNAL) (PID)
  kill -SIGINT 0000
  kill -KILL 0000
  ```
  
  ```Shell
  ```
===============================================================================
Daemon
내가 터미널을 종료시키면 해당 터미널에서 돌아가던 모든 프로세스는 죽음. 그런데 서버를 돌리거나 하는 등의 절대 죽지 않는 프로세스를 만들고 싶을 때가 있음. 그럴 때는 터미널에서 프로세스를 시작하고, 이걸 Daemon에게 보내서 어떠한 입력도 받지 않게 하고, 간섭 받지 않고 컴퓨터가 꺼져도 죽지 않는 프로세스를 만들어야 한다.
  ```Shell
  # 이건 절대 권장하지 않는 방법, 하지만 소개는 한다.
  nohup ./a.out
  # 하면 프로세스가 죽지 않음
  ```
===============================================================================
Coredump (SIGQUIT, SIGNAL ID = 3)
개발을 하면서 가장 까다로운 일은 유저 케이스이다. 대체 어떤 상황이었길래 이런 일이 발생했을까?
이걸 알아보기 위해 많이 쓰는게 Coredump이다.
  ```Shell
  ulimit -a
  # 여기 core file size를 보라
  ```
==============================================================================
환경변수(env)
운영체제가 사용하는 변수 값
시스템 어디서든 사용할 수 있게 특정 경로를 연결해놓는 방법이 있다.
확인 방법

  ```Shell
  echo $PATH
  아니면
  env
  ```
환경변수 등록 방법(예를 들어 현재 pwd를 추가하고 싶다)
  ```Shell
  export PATH=$PATH:. (:가 구분자, .은 토큰)
  export PATH=.:$PATH (위에거랑 다른 의미로 쓰임)
  왜냐면 PATH는 앞에서부터 읽어들이기 때문에 내가 ANACONDA를 쓰고 싶으면 아래 방법을 써야하고, 기존 PYTHON을 쓰고 싶으면 위에걸 하면 됨.
  ```
그리고 이건 PATH이건 변수이고, 현재 내 프로세스에 귀속되어 있다(구체적으로 터미널)
그래서 다른 터미널에서는 사용할 수 없으며, 터미널이 죽으면 모두 없어지는 내용이다.
따라서 따로 시작 파일에다가 저장을 해두거나 하는 방법을 쓰는 경우가 많다.

==============================================================================
이전 명령의 성공 실패 여부를 확인하는 법
  ```Shell
  echo $?
  설명하자면
  ps
  echo $?
  > 0 (이건 ps가 성공적으로 먹혔고, 그 결과로 main이 0을 리턴했다는 이야기)
  123
  echo $?
  > 127 (이건 123이라는 커맨드를 이해하지 못했고, 그럴때 리턴 하는 값이 127이다. 그래서 echo $?가 127을 리턴한 것)
  ```
  
==============================================================================
Profile
bash_profile 또는 bash_login이 있으면 profile 이 무시되고, profile이 무시되면 bashrc가 읽히지 않음.
그래서 권장하는 방법은 profile, bashrc 를 쓰는 것을 권장함.
물론 이것은 리눅스 배포판마다 상이하다.
  


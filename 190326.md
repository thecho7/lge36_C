### Contents
1. [Background & foreground 프로세스](#background-foreground-process)
2. [ps 명령어](#ps)
3. [kill 명령어](#kill)
4. [Daemon이란?](#daemon)
5. [Coredump란?](#coredump)
6. [환경변수에 ](#environment-variable)
7. [이전 명령의 성공 실패 여부를 확인하는 법](#check-command-success)
8. [Profile](#profile)
9. [vi editor](#vi-editor)
10. [정규 표현식](#regular-expression)

### Background foreground process

특정 커맨드(예를 들어 fifo)를 foreground가 아닌 background로 돌리고 싶다!
(foreground는 한 번 입력 받고 끝나는데 반해 back은 계속 돌아가고 있음 (언제까지?))

그러면

  ```Shell
  mkfifo myfifo
  cat hello.txt > myfifo & (뒤에 &가 붙으면 background로 보내겠다)
  ```
  
 그러면 이게 백그라운드 프로세스로 돌아가고 있을 것. 확인할 때는 ps 시리즈로 확인
 
  ```Shell
  # https://arer.tistory.com/150
  ps -l
  ```
===============================================================================
### ps

ps를 통해 현재 돌아가고 있는 프로세스의 대한 정보를 얻을 수 있다. 여러 옵션이 있으므로 위의 주소를 참고

  ```Shell
  PID  TTY
  000 pts/0
  # 000번 프로세스, 가상 터미널 0번에서 구동 중
  ```
===============================================================================  
### kill

  ```Shell
  # kill -l 로 SIGNAL 목록을 확인할 수 있음
  # SIGINT = Ctrl + C, SIGKILL(KILL) -> 막을 수가 없는 명령, 무조건 죽임(나머지 대부분의 SIGNAL은 사용자 재정의 가능)
  # 터미널에서 kill -SIGINT (터미널ID) 해도 아무 일 없지만 kill -KILL (터미널ID) 하면 터미널 죽음
  kill -(SIGNAL) (PID)
  kill -SIGINT 0000
  kill -KILL 0000
  ```
  
  ```Shell
  ```
===============================================================================
### Daemon

내가 터미널을 종료시키면 해당 터미널에서 돌아가던 모든 프로세스는 죽음. 그런데 서버를 돌리거나 하는 등의 절대 죽지 않는 프로세스를 만들고 싶을 때가 있음. 그럴 때는 터미널에서 프로세스를 시작하고, 이걸 Daemon에게 보내서 어떠한 입력도 받지 않게 하고, 간섭 받지 않고 컴퓨터가 꺼져도 죽지 않는 프로세스를 만들어야 한다.
  ```Shell
  # 이건 절대 권장하지 않는 방법, 하지만 소개는 한다.
  nohup ./a.out
  # 하면 프로세스가 죽지 않음
  ```
===============================================================================
### Coredump

(SIGQUIT, SIGNAL ID = 3)
개발을 하면서 가장 까다로운 일은 유저 케이스이다. 대체 어떤 상황이었길래 이런 일이 발생했을까?
이걸 알아보기 위해 많이 쓰는게 Coredump이다.
  ```Shell
  ulimit -a
  # 여기 core file size를 보라
  ```
==============================================================================
### Environment variable

운영체제가 사용하는 변수 값
시스템 어디서든 사용할 수 있게 특정 경로를 연결해놓는 방법이 있다.
확인 방법

  ```Shell
  echo $PATH
  아니면
  env
  ```
환경변수 등록 방법(예를 들어 현재 pwd를 추가하고 싶다)
  ```Shell
  export PATH=$PATH:. (:가 구분자, .은 토큰)
  export PATH=.:$PATH (위에거랑 다른 의미로 쓰임)
  왜냐면 PATH는 앞에서부터 읽어들이기 때문에 내가 ANACONDA를 쓰고 싶으면 아래 방법을 써야하고, 기존 PYTHON을 쓰고 싶으면 위에걸 하면 됨.
  ```
그리고 이건 PATH이건 변수이고, 현재 내 프로세스에 귀속되어 있다(구체적으로 터미널)
그래서 다른 터미널에서는 사용할 수 없으며, 터미널이 죽으면 모두 없어지는 내용이다.
따라서 따로 시작 파일에다가 저장을 해두거나 하는 방법을 쓰는 경우가 많다.

==============================================================================
### Check Command Success

이전 명령의 성공 실패 여부를 확인하는 법
  ```Shell
  echo $?
  설명하자면
  ps
  echo $?
  > 0 (이건 ps가 성공적으로 먹혔고, 그 결과로 main이 0을 리턴했다는 이야기)
  123
  echo $?
  > 127 (이건 123이라는 커맨드를 이해하지 못했고, 그럴때 리턴 하는 값이 127이다. 그래서 echo $?가 127을 리턴한 것)
  ```
  
==============================================================================
### Profile

bash_profile 또는 bash_login이 있으면 profile 이 무시되고, profile이 무시되면 bashrc가 읽히지 않음.
그래서 권장하는 방법은 profile, bashrc 를 쓰는 것을 권장함.
물론 이것은 리눅스 배포판마다 상이하다.
  
==============================================================================
### vi editor

에디터 시간(VI, VIM, SPACE VIM, NEO VIM ...)

    이동(hjkl)
    모드(입력(default), 명령, ex 모드)
    명령 -> 입력
     i: insert
     a: append
     o: 다음 줄에서 입력 모드 시작
     O: 이전 줄에서 입력 모드 시작
    
    입력 -> 명령
    esc
    
    명령
      복사(y)
        yy: 한줄 복사
        y^: 커서의 위치부터 문장의 시작까지
        y$: 커서의 위치부터 문장의 끝까지
      
      잘라내기(d)
        dd: 한줄 잘라내기
        d^: 커서의 위치부터 문장의 시작까지
        d$: 커서의 위치부터 문장의 끝까지
      
      붙여넣기(p)
     
      범위
        ^: 문장의 시작
        $: 문장의 끝
        gg: 문서의 시작
        G: 문서의 끝
      
      영역 선택
        v: 한 글자 선택
        V: 한 라인 선택
      
      실행 / 실행 취소
        undo: u
        redo: Ctrl + r
        
==============================================================================
## Regular expression

**정규 표현식**(아주 중요)

이메일 유효성, 비밀번호 유효성, 각종 패턴의 유효성 확인에서 아주 쉽고 간단하게 쓰임.
중요성은 이루 말할 수 없다.
:특정한 규칙을 가진 문자열의 집합을 표현하는 데 사용하는 형식 언어

**형식**
    (출력 명령어) | grep -(옵션) '(표현식)'
예)     ls .     | grep   -E     '[0-9]'
해석) 현재 디렉토리의 내용물의 리스트 중, 0~9까지의 숫자가 포함된 파일의 목록을 보여준다. (확장 정규 표현식을 사용하여)

    grep -(옵션) '(표현식)' (파일)
예) grep   -c     '[0-9]' test.txt
해석) test.txt 파일 내에서 0~9까지의 숫자가 포함된 행의 개수를 출력한다.

### 출력 명령어
뭐든 상관없다. cat, ls, tail, head 등등 stdout 모든 것.

### 옵션
  ```Shell
  -c: 해당하는 행의 개수
  -n: 행을 번호와 함께 출력
  -i: 검색 시, 대소문자 구별 X
  -l: 패턴이 포함된 파일의 이름 출력
  -L: 패턴이 포함되지 않은 파일의 이름 출력
  -r: 하위 디렉토리까지 검색하여 출력
  -w: 패턴이 단어로써 일치하는 행만 출력(단어가 정확히 그 패턴이어야 한다)
  -v: 해당 문자열이 포함되어 있지 않은 라인을 출력
  ```
### 정규 표현식
  ```Shell
  .
  - 임의의 한 문자와 대응(반드시 대응해야 함(공백까지 해당됨))
  - 두 개 이상 사용 가능
  - 마침표(.) 문자 자체를 패턴으로서 쓰고 싶으면 \. 로 사용
  
  ^, $
  - 각각 문자열이나 행의 시작과 끝 패턴을 표현하는데 쓰임
  - '^123' '123$' '^123$'(그 문자열 또는 행이 딱 123인 경우)
  
  []
  - OR의 표현, 문자 집합 중 [] 안에 특정 문자와 일치하는지 확인
  - [0-9] [a-z] [A-Z] [a-zA-Z] 등의 범위 지정자와 함께 쓰는 것이 가능
  - [] 안쪽에 ^를 사용하면 부정의 의미임([^0-9] 는 숫자 포함 불가를 의미. ^ 붙이는 순간 [] 내의 문자를 전부 부정한다는 의미)
  
  *
  - * 앞의 문자가 0개 이상 반복되는 경우를 의미함
  - a*b = b, ab aab aaab ...
  
  # 여기서부터는 확장 정규 표현식이므로, grep -E, egrep, ag 등등을 사용해야만 함
  +
  - 앞의 한 문자가 1번 이상 반복되는 개념(*와 다른 점은 앞의 문자가 무조건 들어가야 한다는 것)
  - a+b = ab, aab, aaab, ...
  
  ?
  - 앞의 한 문자가 0번 또는 1번 쓰이는 경우
  - a?b = b, ab
  - www? = ww. www
  
  {}
  - 반복 횟수를 지정해주는 경우
  - '[0-9]{n}' = 0~9까지의 숫자가 연속해서 n번이 나오는 경우
  - '[[:lower:]]{n,}' = 영소문자가 연속해서 n번 이상 나오는 경우
  - '[[:blank:]]{n,m}' = 공백이 연속해서 n번 이상 m번 이하 나오는 경우
  
  |
  - 2개 이상의 패턴에 대해 or 연산으로 검사하는 경우
  - 'abc|acb'= abc 또는 acb에 대해 검사
  - '^abc|^gcc' = 문자열 또는 행이 abc 또는 gcc로 시작하는 경우
  ```
